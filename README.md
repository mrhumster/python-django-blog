[Build a Blog Using Django, Vue, and GraphQL](https://realpython.com/python-django-blog/)

# Введение

Вы постоянный пользователь Django? Вы обнаружили, что хотите разделить бэк и фронт? 
Вы хотите обрабатывать сохраняемость данных в API при отображении данных в одностраничном приложении (SPA) в браузере 
с использованием клиентской среды, такой как React или Vue? Вам повезло. 

Это руководство проведет вас через процесс создания серверной части блога Django и внешнего интерфейса Vue с 
использованием [GraphQL](https://graphql.org/) для связи между ними.

Проекты — это эффективный способ изучения и закрепления концепций. Этот учебник структурирован как пошаговый проект, 
поэтому вы можете учиться на практике и делать перерывы по мере необходимости.

В этом уроке вы узнаете, как:

* Переведите свои модели Django в GraphQL API
* Запустите сервер Django и приложение Vue на своем компьютере одновременно
* Управляйте своими сообщениями в блоге в панели администратора Django
* Используйте GraphQL API в Vue для отображения данных в браузере


# Обзор проекта

Вы создадите небольшое приложение для ведения блога с некоторыми элементарными функциями.
Авторы могут писать много постов. Посты могут иметь много тегов и могут быть как опубликованными, так и 
неопубликованными.

Вы создадите серверную часть этого блога в Django вместе с администратором для добавления нового контента в блог. 
Затем вы предоставите данные контента в виде GraphQL API и используете Vue для отображения этих данных в браузере. 
Вы сделаете это за несколько высокоуровневых шагов:

* Настройте блог Django
* Создайте администратора блога Django
* Настройте Graphene-Django
* Настройте заголовки django-cors
* Настроить Vue.js
* Настроить Vue-маршрутизатор
* Создайте компоненты Vue
* Получить данные

Каждый раздел будет содержать ссылки на любые необходимые ресурсы и даст вам возможность сделать паузу и вернуться по 
мере необходимости.

# Предпосылки

Вы будете лучше подготовлены к этому руководству, если у вас уже есть прочная основа в некоторых концепциях 
веб-приложений. Вы должны понимать, как работают HTTP-запросы и ответы, а также API. Вы можете проверить Python 
и API: выигрышная комбинация для чтения общедоступных данных, чтобы понять подробности использования API GraphQL 
и API REST.

Поскольку вы будете использовать Django для создания серверной части своего блога, вам необходимо ознакомиться с 
запуском проекта Django и настройкой администратора Django. Если вы раньше не использовали Django, вы также можете 
сначала попробовать создать другой проект только для Django. 
Для хорошего ознакомления ознакомьтесь с Начало работы с Django, часть 1: создание приложения для портфолио.

Поскольку вы будете использовать Vue на внешнем интерфейсе, некоторый опыт работы с реактивным JavaScript также 
поможет. Если в прошлом вы использовали парадигму манипулирования DOM только с таким фреймворком, как jQuery, 
знакомство с Vue — хорошая основа.

Знакомство с JSON также важно, потому что запросы GraphQL похожи на JSON и возвращают данные в формате JSON. 
Вы можете прочитать о работе с данными JSON в Python для ознакомления. Вам также потребуется установить Node.js 
для работы с внешним интерфейсом позже в этом руководстве.

# Шаг 1: Настройте блог Django

Прежде чем заходить слишком далеко, вам понадобится каталог, в котором вы сможете организовать код для своего проекта. 
Начните с создания файла с именем dvg/, сокращение от Django-Vue-GraphQL:

```shell
$ mkdir dvg/
$ cd dvg/
```

Вы также будете полностью разделять интерфейсный и серверный код, поэтому рекомендуется начать создавать это 
разделение сразу же. Создайте каталог backend/ в каталоге вашего проекта:

```shell
$ mkdir backend/
$ cd backend/
```

Вы поместите свой код Django в этот каталог, полностью изолированный от кода Vue, который вы создадите позже в 
этом руководстве.

## Установка Django

Теперь вы готовы приступить к созданию приложения Django. Чтобы отделить зависимости для этого проекта от других ваших
проектов, создайте виртуальную среду, в которой вы будете устанавливать требования вашего проекта. Вы можете узнать 
больше о виртуальных средах в Python Virtual Environments: A Primer. В остальной части руководства предполагается, 
что вы будете запускать команды, связанные с Python и Django, в вашей активной виртуальной среде.

Теперь, когда у вас есть виртуальная среда для установки требований, создайте файл requirements.txt в каталоге 
backend/ и определите первое необходимое требование:

```requirements.txt
Django==3.1.7
```

Сохранив файл requirements.txt, используйте его для установки Django:

```shell
python -m pip install -r requirements.txt
```

Теперь вы сможете приступить к созданию своего проекта Django.

## Создание проекта Django

Теперь, когда Django установлен, используйте команду django-admin для [инициализации вашего проекта Django](https://realpython.com/django-setup/):

```shell
django-admin startproject backend .
```

Это создает модуль `manage.py` и бэкэнд-пакет в каталоге `backend/`, поэтому структура каталогов вашего проекта 
теперь должна выглядеть так:

```shell
.
├── dvg
│   └── backend
│       ├── backend
│       │   ├── asgi.py
│       │   ├── __init__.py
│       │   ├── settings.py
│       │   ├── urls.py
│       │   └── wsgi.py
│       ├── manage.py
│       └── requirements.txt
└── README.md
```

Этот учебник не будет охватывать все эти файлы и не будет нуждаться в них, но их присутствие не повредит.

## Запуск Django Migrations

Прежде чем добавлять что-то конкретное в ваше приложение, вы также должны запустить первоначальные миграции Django. 
Если вы раньше не имели дело с миграциями, ознакомьтесь с [Django Migrations: A Primer](https://realpython.com/django-migrations-a-primer/).
Запустите миграцию с помощью команды управления миграцией:

```shell
python manage.py migrate
```

Вы должны увидеть длинный список миграций, за каждой из которых следует OK:

```text
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK
```

Это создаст файл базы данных SQLite с именем `db.sqlite3`, в котором также будут храниться остальные данные для вашего 
проекта.

## Создадим администратора

Теперь, когда у вас есть база данных, вы можете создать суперпользователя. Вам понадобится этот пользователь, 
чтобы вы могли в конечном итоге войти в интерфейс администратора Django. Используйте команду управления 
`createsuperuser`, чтобы создать его:

```shell
python manage.py createsuperuser
```

Вы сможете использовать имя пользователя и пароль, которые вы указали на этом шаге, для входа в административную панель 
Django в следующем разделе.

## В итоге после первого шага

Теперь, когда вы установили Django, создали проект Django, запустили миграцию Django и создали суперпользователя, у 
вас есть полностью работающее приложение Django. Теперь вы сможете запустить сервер разработки Django и просмотреть 
его в своем браузере. Запустите сервер с помощью команды управления runserver, которая по умолчанию будет прослушивать 
порт 8000:

```shell
python manage.py runserver
```

Теперь посетите `http://localhost:8000` в своем браузере. Вы должны увидеть заставку Django, указывающую на то, что
установка прошла успешно. Вы также должны иметь возможность посетить `http://localhost:8000/admin`, где вы увидите 
форму входа.

Используйте имя пользователя и пароль, которые вы создали для своего суперпользователя, чтобы войти в 
административную панель Django. Если все работает, вы попадете на страницу панели администратора Django. На данный 
момент эта страница будет довольно пустой, но на следующем шаге вы сделаете ее намного интереснее.

# Шаг 2: Создайте администратора блога Django

Теперь, когда у вас есть основа вашего проекта Django, вы готовы приступить к созданию основной бизнес-логики для 
своего блога. На этом шаге вы создадите модели данных и административную конфигурацию для создания контента блога 
и управления им.

## Создайте приложение блога Django

Имейте в виду, что один проект Django может содержать множество приложений Django. Вы должны отделить свое поведение, 
связанное с блогом, в отдельное приложение Django, чтобы оно оставалось отличным от любых будущих приложений, которые 
вы встроите в свой проект. Создайте приложение с помощью команды управления startapp:

```shell
python manage.py startapp blog
```

Это создаст каталог `blog/` с несколькими скелетными файлами:

```shell
blog/
├── admin.py
├── apps.py
├── __init__.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py
```

Позже в этом руководстве вы внесете изменения и дополнения в некоторые из этих файлов.

## Включить приложение блога Django

Создание приложения Django не делает его доступным в вашем проекте по умолчанию. Чтобы убедиться, что проект знает о 
вашем новом приложении для блога, вам нужно добавить его в список установленных приложений. Обновите переменную 
`INSTALLED_APPS` в файле `backend/settings.py`:

```python
INSTALLED_APPS = [
  ...
  "blog",
]
```

Это поможет Django обнаружить информацию о вашем приложении, такую как модели данных и шаблоны URL, которые оно 
содержит.

## Создание моделей данных блога Django

Теперь, когда Django может обнаружить ваше приложение блога, вы можете создавать модели данных. Для начала вы 
создадите три модели:

1) Профиль хранит дополнительную информацию о пользователях блога.
2) Тег представляет собой категорию, в которой могут быть сгруппированы сообщения блога.
3) Сообщение хранит содержимое и метаданные каждого сообщения в блоге.

Вы добавите каждую из этих моделей в `blog/models.py`. Сначала импортируйте модуль `Django django.db.models`:

```python
from django.db import models
```

Каждая из ваших моделей будет наследоваться от класса models.Model.

### Модель `profile`

Модель профиля будет иметь несколько полей:

* `user` — это прямая связь с пользователем Django, с которым связан профиль.
* `website` — необязательный URL-адрес, по которому вы можете узнать больше о пользователе.
* `bio` – это необязательная реклама размером с твит, позволяющая быстро узнать больше о пользователе.

Сначала вам нужно импортировать модуль настроек из Django:

```python
from django.conf import settings
```

Затем создайте модель профиля, которая должна выглядеть следующим образом:

```python
class Profile(models.Model):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.PROTECT,
    )
    website = models.URLField(blank=True)
    bio = models.CharField(max_length=240, blank=True)

    def __str__(self):
        return self.user.get_username()
```

Метод `__str__` заставит создаваемые вами объекты профиля отображаться в более удобном для человека виде на сайте 
администратора.

### Модель `tag`

Модель тега имеет только одно поле, имя, в котором хранится короткое уникальное имя тега. Создайте модель тега, которая
должна выглядеть следующим образом:

```python
class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)

    def __str__(self):
        return self.name
```

Опять же, `__str__` заставит созданные вами объекты тегов отображаться на сайте администратора в более удобном для 
человека виде.

### Модель `post`

Модель Post, как вы можете себе представить, является наиболее сложной. В нем будет несколько полей:

| Имя поля         | Цель                                                                                                      |
|------------------|-----------------------------------------------------------------------------------------------------------|
| title            | Уникальный заголовок поста, отображаемый читателям.                                                       |
| subtitle         | Необязательный поясняющий элемент содержания поста, помогающий читателям понять, хотят ли они его читать. |
| slug             | Уникальный читаемый идентификатор сообщения для использования в URL-адресах.                              |
| body             | Содержание поста                                                                                          |
| meta_description | Необязательное описание для поисковых систем, таких как Google.                                           |
| date_created     | Отметка времени создания сообщения.                                                                       |
| date_modified    | Отметка времени последнего редактирования сообщения.                                                      |
| publish_date     | Необязательная временная метка, когда сообщение выходит в эфир.                                           |
| published        | Доступна ли запись в данный момент для читателей                                                          |
| author           | Ссылка на профиль пользователя, написавшего сообщение                                                     |
| tags             | Список тегов, связанных с постом, если они есть                                                           |

Поскольку в блогах обычно первыми отображаются самые последние сообщения, вам также нужно упорядочить их по дате 
публикации, причем сначала будут самые последние. Создайте модель Post, которая должна выглядеть следующим образом:

```python
class Post(models.Model):
    class Meta:
        ordering = ["-publish_date"]

    title = models.CharField(max_length=255, unique=True)
    subtitle = models.CharField(max_length=255, blank=True)
    slug = models.SlugField(max_length=255, unique=True)
    body = models.TextField()
    meta_description = models.CharField(max_length=150, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    date_modified = models.DateTimeField(auto_now=True)
    publish_date = models.DateTimeField(blank=True, null=True)
    published = models.BooleanField(default=False)

    author = models.ForeignKey(Profile, on_delete=models.PROTECT)
    tags = models.ManyToManyField(Tag, blank=True)
```

Аргумент `on_delete=models.PROTECT` для автора гарантирует, что вы случайно не удалите автора, у которого все еще 
есть сообщения в блоге. Отношение `ManyToManyField` к тегу позволяет связать запись с нулем или более тегами. 
Каждый тег может быть связан со многими сообщениями.

## Создайте конфигурацию администратора модели

Теперь, когда ваши модели на месте, вам нужно указать Django, как они должны отображаться в интерфейсе администратора. 
В `blog/admin.py` начните с импорта административного модуля Django и ваших моделей:

```python
from django.contrib import admin

from blog.models import Profile, Post, Tag
```

Затем создайте и зарегистрируйте классы администратора для профиля и тега, которым нужна только указанная модель:

```python
@admin.register(Profile)
class ProfileAdmin(admin.ModelAdmin):
    model = Profile

@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    model = Tag
```

Как и в модели, класс администратора для Post более вовлечен. Сообщения содержат много информации, поэтому полезно 
более разумно подходить к тому, какую информацию отображать, чтобы избежать переполнения интерфейса.

В списке всех сообщений вы укажете, что Django должен отображать только следующую информацию о каждом сообщении:

 1) ID
 2) Title
 3) Subtitle
 4) Slug
 5) Publish date
 6) Publish status

Чтобы упростить просмотр и редактирование сообщений, вы также сообщите системе администратора Django о следующих 
действиях:

* Разрешить фильтрацию списка сообщений по опубликованным или неопубликованным сообщениям.
* Разрешить фильтрацию сообщений по дате публикации.
* Разрешить редактирование всех отображаемых полей, кроме ID.
* Разрешить поиск сообщений по заголовку, подзаголовку, слагу и телу.
* Предварительно заполните поле slug, используя поля заголовка и подзаголовка.
* Используйте дату публикации всех сообщений, чтобы создать доступную для просмотра иерархию дат.
* Покажите кнопку вверху списка, чтобы сохранить изменения.

Создайте и зарегистрируйте класс PostAdmin:

```python
@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    model = Post

    list_display = (
        "id",
        "title",
        "subtitle",
        "slug",
        "publish_date",
        "published",
    )
    list_filter = (
        "published",
        "publish_date",
    )
    list_editable = (
        "title",
        "subtitle",
        "slug",
        "publish_date",
        "published",
    )
    search_fields = (
        "title",
        "subtitle",
        "slug",
        "body",
    )
    prepopulated_fields = {
        "slug": (
            "title",
            "subtitle",
        )
    }
    date_hierarchy = "publish_date"
    save_on_top = True
```

Вы можете узнать больше обо всех возможностях, которые может предложить администратор Django, 
в разделе [Настройка администратора Django](https://realpython.com/customize-django-admin-python/) с помощью Python.

## Создание миграций моделей

В Django есть вся информация, необходимая для администрирования и сохранения контента вашего блога, но сначала вам 
нужно обновить базу данных, чтобы поддерживать эти изменения. Ранее в этом руководстве вы запускали миграции Django для 
его встроенных моделей. Теперь вы создадите и запустите миграции для своих моделей.

Сначала создайте миграции с помощью команды управления `makemigrations`:

```shell
python manage.py makemigrations
```

Это создает миграцию с именем по умолчанию `0001_initial.py`. Запустите эту миграцию с помощью команды управления 
миграцией:

```shell
python manage.py migrate
```

## Резюме шага 2

Теперь у вас есть все ваши модели данных, и вы настроили администратора Django, чтобы вы могли добавлять и 
редактировать эти модели.

Запустите или перезапустите сервер разработки Django, посетите интерфейс администратора по адресу 
`http://localhost:8000/admin` и изучите, что изменилось. Вы должны увидеть ссылки на список тегов, профилей и 
сообщений, а также ссылки для добавления или редактирования каждого из них. Попробуйте добавить и отредактировать 
несколько из каждого, чтобы увидеть, как реагирует интерфейс администратора.

# Шаг 3: Установка `graphene-django`

К этому моменту вы завершили достаточно работы с серверной частью, чтобы решить идти сломя голову в направлении 
Django. Вы можете использовать механизм URL-маршрутизации и шаблонов Django для создания страниц, которые будут 
отображать весь контент сообщений, который вы создаете в админке, для читателей. Вместо этого вы оберните созданную 
вами серверную часть в GraphQL API, чтобы в конечном итоге вы могли использовать ее из браузера и предоставить 
более богатый опыт на стороне клиента.

GraphQL позволяет вам извлекать только те данные, которые вам нужны, что может быть полезно по сравнению с очень 
большими ответами, которые распространены в RESTful API. GraphQL также обеспечивает большую гибкость при 
проецировании данных, поэтому вы часто можете извлекать данные новыми способами, не изменяя логику службы, 
предоставляющей GraphQL API.

Вы будете использовать [Graphene-Django](https://docs.graphene-python.org/projects/django/en/latest/) для интеграции того, что вы уже создали, в GraphQL API.

## Установка `graphene-django`

Чтобы начать работу с Graphene-Django, сначала добавьте его в файл требований вашего проекта:

```requirements.txt
graphene-django==2.14.0
```

Добавьте `graphene_django` в переменную `INSTALLED_APPS` в модуле `settings.py` вашего проекта, 
чтобы Django его нашел:

```python
INSTALLED_APPS = [
  ...
  "blog",
  "graphene_django",
]
```

## Настроить Graphene-Django

Чтобы Graphene-Django работал в вашем проекте, вам нужно настроить несколько частей:

1) Обновите `settings.py`, чтобы проект знал, где искать информацию GraphQL.
2) Добавьте шаблон URL для обслуживания GraphQL API и GraphiQL, доступного для изучения интерфейса GraphQL.
3) Создайте схему GraphQL, чтобы Graphene-Django знал, как перевести ваши модели в GraphQL.

## Обновите настройки Джанго

Параметр `GRAPHENE` настраивает `Graphene-Django` на поиск вашей схемы GraphQL в определенном месте. 
Укажите путь`blog.schema.schema` Python, который вы вскоре создадите:

```python
GRAPHENE = {
  "SCHEMA": "blog.schema.schema",
}
```

Обратите внимание, что это дополнение может привести к тому, что Django выдаст ошибку импорта, которую вы 
устраните при создании схемы GraphQL.

## Добавьте шаблон URL для GraphQL и GraphiQL

Чтобы позволить Django обслуживать конечную точку GraphQL и интерфейс GraphiQL, вы добавите новый шаблон URL в 
`backend/urls.py`. Вы укажете URL-адрес Graphene-Django `GraphQLView`. 

> Поскольку вы не используете функции защиты от подделки межсайтовых запросов (CSRF) 
> механизма шаблонов Django, вам также потребуется импортировать декоратор Django `csrf_exempt`, 
> чтобы пометить представление как освобожденное от защиты CSRF:

```python
from django.views.decorators.csrf import csrf_exempt
from graphene_django.views import GraphQLView
```

Затем добавьте в переменную `urlpatterns` новый шаблон URL:

```python
urlpatterns = [
    ...
    path("graphql", csrf_exempt(GraphQLView.as_view(graphiql=True))),
]
```

Аргумент `graphiql=True` говорит `Graphene-Django` сделать интерфейс GraphiQL доступным.

## Создайте схему GraphQL

Теперь вы создадите схему GraphQL, которая должна быть похожа на конфигурацию администратора, которую вы создали 
ранее. Схема состоит из нескольких классов, каждый из которых связан с определенной моделью Django, и **одного**, 
определяющего, как разрешать несколько важных типов запросов, которые вам понадобятся во внешнем интерфейсе.

Создайте новый модуль `blog/schema.py`. Импортируйте `Graphene-Django` `DjangoObjectType`, ваши модели `blog` и `User`:

```python
from django.contrib.auth import get_user_model
from graphene_django import DjangoObjectType

from blog import models
```

Создайте соответствующий класс для каждой из ваших моделей и модели `User`. Каждое из них должно иметь имя, 
оканчивающееся на `Type` потому, что каждое из них представляет тип GraphQL. Ваши классы должны выглядеть 
следующим образом:

```python
class UserType(DjangoObjectType):
    class Meta:
        model = get_user_model()

class AuthorType(DjangoObjectType):
    class Meta:
        model = models.Profile

class PostType(DjangoObjectType):
    class Meta:
        model = models.Post

class TagType(DjangoObjectType):
    class Meta:
        model = models.Tag
```

Вам нужно создать класс `Query`, который наследуется от `graphene.ObjectType`. Этот класс объединит все созданные 
вами классы типов, и вы добавите к нему методы, указывающие способы, которыми можно запрашивать ваши модели. 

Сначала вам нужно импортировать graphene:

```python
import graphene
```

Класс `Query` состоит из ряда атрибутов, которые являются или `graphene.List` или `graphene.Field`. 
Вы будете использовать `graphene.Field`, если запрос должен возвращать один элемент и `graphene.List`, если он 
возвращает несколько элементов.

Для каждого из этих атрибутов вы также создадите метод для разрешения запроса. Вы решаете запрос, беря информацию, 
предоставленную в запросе, и возвращая в ответ соответствующий набор запросов Django.

Метод для каждого преобразователя должен начинаться с `resolve_`, а остальная часть имени должна соответствовать 
соответствующему атрибуту. Например, метод для разрешения набора запросов для `all_posts` атрибута должен 
называться `resolve_all_posts`.

Вы создадите запросы, чтобы получить:

1) Все посты
2) Автор с заданным именем пользователя
3) Пост с заданным слагом
4) Все сообщения данного автора
5) Все посты с указанным тегом

6) Создайте `Query` класс сейчас. Это должно выглядеть как следующий фрагмент:

```python
class Query(graphene.ObjectType):
    all_posts = graphene.List(PostType)
    author_by_username = graphene.Field(AuthorType, username=graphene.String())
    post_by_slug = graphene.Field(PostType, slug=graphene.String())
    posts_by_author = graphene.List(PostType, username=graphene.String())
    posts_by_tag = graphene.List(PostType, tag=graphene.String())

    def resolve_all_posts(root, info):
        return (
            models.Post.objects.prefetch_related("tags")
            .select_related("author")
            .all()
        )

    def resolve_author_by_username(root, info, username):
        return models.Profile.objects.select_related("user").get(
            user__username=username
        )

    def resolve_post_by_slug(root, info, slug):
        return (
            models.Post.objects.prefetch_related("tags")
            .select_related("author")
            .get(slug=slug)
        )

    def resolve_posts_by_author(root, info, username):
        return (
            models.Post.objects.prefetch_related("tags")
            .select_related("author")
            .filter(author__user__username=username)
        )

    def resolve_posts_by_tag(root, info, tag):
        return (
            models.Post.objects.prefetch_related("tags")
            .select_related("author")
            .filter(tags__name__iexact=tag)
        )
```

Теперь у вас есть все типы и преобразователи для вашей схемы, но помните, что созданная вами переменная `GRAPHENE` 
указывает на `blog.schema.schema`. Создайте переменную `schema`, которая обертывает ваш класс `Query` `graphene.Schema`,
чтобы связать все вместе:

```python
schema = graphene.Schema(query=Query)
```

Эта переменная соответствует значению `"blog.schema.schema"`, которое вы настроили для Graphene-Django ранее в этом 
руководстве.

## Шаг 3. Резюме

Вы конкретизировали модель данных своего блога, и теперь вы также обернули свою модель данных с помощью 
Graphene-Django, чтобы использовать эти данные в качестве GraphQL API.

Запустите сервер разработки Django и посетите `http://localhost:8000/graphql`. Вы должны увидеть интерфейс 
GraphiQL с текстом комментариев, который объясняет, как использовать инструмент.

Разверните раздел «Документы» в правом верхнем углу экрана и нажмите запрос: Запрос. Вы должны увидеть все 
запросы и типы, которые вы настроили в своей схеме.

Если вы еще не создали тестовый контент для блога, сделайте это сейчас. Попробуйте выполнить следующий запрос, 
который должен вернуть список всех созданных вами сообщений:

```yaml
{
  allPosts {
    title
    subtitle
    author {
      user {
        username
      }
    }
    tags {
      name
    }
  }
}
```

Ответ должен вернуть список сообщений. Структура каждого поста должна соответствовать форме запроса, как в 
следующем примере:

```json
{
  "data": {
    "allPosts": [
      {
        "title": "The Great Coney Island Debate",
        "subtitle": "American or Lafayette?",
        "author": {
          "user": {
            "username": "coney15land"
          }
        },
        "tags": [
          {
            "name": "food"
          },
          {
            "name": "coney island"
          }
        ]
      }
    ]
  }
}
```

Если вы сохранили несколько сообщений и видите их в ответах, значит, вы готовы продолжить.

# Шаг 4: Настройка `django-cors-headers`

Вам нужно будет сделать еще один шаг, прежде чем вы сможете назвать внутреннюю работу завершенной. Поскольку 
серверная часть и клиентская часть будут работать на разных портах локально, а также поскольку они могут 
работать в совершенно разных доменах в производственной среде, в игру вступает совместное использование 
ресурсов между источниками (CORS). Без обработки CORS запросы от внешнего интерфейса к внутреннему обычно 
блокируются вашим браузером.

Проект `django-cors-headers` делает работу с CORS довольно безболезненной. Вы будете использовать это, 
чтобы указать Django отвечать на запросы, даже если они исходят из другого источника, что позволит внешнему 
интерфейсу правильно взаимодействовать с API GraphQL.

## Установить `django-cors-headers`

Сначала добавьте `django-cors-headers` в файл требований:

```requirements.txt
django-cors-headers==3.6.0
```

Затем установите его, используя обновленный файл требований:

```shell
(venv) $ python -m pip install -r requirements.txt
```

Добавьте `"corsheaders"` в `INSTALLED_APPS` список в `settings.py` модуле вашего проекта:

```python
INSTALLED_APPS = [
  ...
  "corsheaders",
]
```


Затем добавьте `"corsheaders.middleware.CorsMiddleware"`  переменной `MIDDLEWARE`:

```python
MIDDLEWARE = [
  "corsheaders.middleware.CorsMiddleware",
  ...
]
```

Документация `django-cors-headers` предлагает размещать промежуточное ПО как можно раньше в списке `MIDDLEWARE`. 
Вы можете поставить его в самом верху списка в этом проекте.

## Настройка `django-cors-headers`

CORS существует по уважительной причине. Вы не хотите, чтобы ваше приложение использовалось из любого места в 
Интернете. Вы можете использовать два параметра, чтобы очень точно определить, насколько вы хотите открыть 
GraphQL API:

* `CORS_ORIGIN_ALLOW_ALL` определяет, должен ли Django быть полностью открытым или полностью закрытым по умолчанию.
* `CORS_ORIGIN_WHITELIST` определяет, из каких доменов ваше приложение Django будет разрешать запросы.

Добавьте следующие настройки в `settings.py`:

```python
CORS_ORIGIN_ALLOW_ALL = False
CORS_ORIGIN_WHITELIST = ("http://localhost:8080",)
```

Эти настройки разрешат запросы только от вашего внешнего интерфейса, который вы в конечном итоге будете запускать 
локально на порту **8080**.

## Шаг 4. Резюме
Бэк готов! У вас есть работающая модель данных, работающий интерфейс администратора, рабочий API GraphQL, который 
вы можете изучить с помощью GraphiQL, и возможность запрашивать API из внешнего интерфейса, который вы создадите 
дальше. Это отличное место, чтобы сделать паузу, если вы давно не отдыхали.

